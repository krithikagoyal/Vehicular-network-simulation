/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2007 INRIA
 *               2009,2010 Contributors
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Mart√≠n Giachino <martin.giachino@gmail.com>
 *
 *
 * This example demonstrates the use of Ns2MobilityHelper class to work with mobility.
 *
 * Detailed example description.
 *
 *  - intended usage: this should be used in order to load ns2 movement trace files into ns3.
 *  - behavior:
 *      - Ns2MobilityHelper object is created, associated to the specified trace file.
 *      - A log file is created, using the log file name argument.
 *      - A node container is created with the number of nodes specified in the command line.  For the default ns-2 trace, specify the value 2 for this argument.
 *      - the program calls the Install() method of Ns2MobilityHelper to set mobility to nodes. At this moment, the file is read line by line, and the movement is scheduled in the simulator.
 *      - A callback is configured, so each time a node changes its course a log message is printed.
 *  - expected output: example prints out messages generated by each read line from the ns2 movement trace file.
 *                     For each line, it shows if the line is correct, or of it has errors and in this case it will
 *                     be ignored.
 *
 * Usage of ns2-mobility-trace:
 *
 *  ./waf --run "ns2-mobility-trace \
 *        --traceFile=src/mobility/examples/default.ns_movements
 *        --nodeNum=2  --duration=100.0 --logFile=ns2-mobility-trace.log"
 *
 *  NOTE: ns2-traces-file could be an absolute or relative path. You could use the file default.ns_movements
 *        included in the same directory as the example file.
 *  NOTE 2: Number of nodes present in the trace file must match with the command line argument.
 *          Note that you must know it before to be able to load it.
 *  NOTE 3: Duration must be a positive number and should match the trace file. Note that you must know it before to be able to load it.
 */

#include <fstream>
#include <iostream>
#include <sstream>

#include "ns3/aodv-helper.h"
#include "ns3/aodv-routing-protocol.h"
#include "ns3/applications-module.h"
#include "ns3/command-line.h"
#include "ns3/config.h"
#include "ns3/core-module.h"
#include "ns3/double.h"
#include "ns3/internet-module.h"
#include "ns3/internet-stack-helper.h"
#include "ns3/ipv4-address-helper.h"
#include "ns3/ipv4-interface-container.h"
#include "ns3/ipv4-list-routing.h"
#include "ns3/log.h"
#include "ns3/mobility-helper.h"
#include "ns3/mobility-model.h"
#include "ns3/mobility-module.h"
#include "ns3/netanim-module.h"
#include "ns3/network-module.h"
#include "ns3/node-list.h"
#include "ns3/ns2-mobility-helper.h"
#include "ns3/ocb-wifi-mac.h"
#include "ns3/olsr-helper.h"
#include "ns3/olsr-routing-protocol.h"
#include "ns3/packet.h"
#include "ns3/point-to-point-module.h"
#include "ns3/position-allocator.h"
#include "ns3/socket.h"
#include "ns3/string.h"
#include "ns3/tag.h"
#include "ns3/traffic-control-helper.h"
#include "ns3/uinteger.h"
#include "ns3/vector.h"
#include "ns3/wave-mac-helper.h"
#include "ns3/wifi-80211p-helper.h"
#include "ns3/yans-wifi-helper.h"

// ./waf --run "scratch/ns2-mobility-trace --traceFile=scratch/mobility4_349.tcl --nodeNum=349 --duration=3600.0 --logFile=ns2-mob.log"
// ./waf --run "scratch/ns2-mobility-trace --traceFile=scratch/mobility2_57.tcl --nodeNum=57 --duration=3600.0 --logFile=ns2-mob.log"
// ./waf --run "scratch/ns2-mobility-trace --traceFile=scratch/mobility3_136.tcl --nodeNum=136 --duration=3600.0 --logFile=ns2-mob.log"

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("WifiSimpleOcb");
NodeContainer stas;
NodeContainer rsu;
std::string tracebase = "scratch/wireless";

class MyNode {
   public:
    Address addr;
    uint8_t type;
    double x;
    double y;
    uint32_t id;
};

// 0: 1, 82.0, x = 791.92, y = 693.34, 47, myX = 826.88, myY = 685.35, pX = 913.0, pY = 757.1
// 1: 3, 30.0
// 2: 11, 30.0, x = 211.82 y = 277.34, myX = 186.55, myY = 262.53, pX = 199.185, pY = 269.935
// 4: 195, 30.0, x = 169.14 y = 289.78, myX = 154.78, myY = 297.6, pX = 161.96,pY = 293.69
uint32_t patientNode = 1;
double emergencyOccurenceTime = 82.0;
// mobility 0: 66, 81, 20, 39, 91, 30, 61, 47, 68, 107
// mobility 1: 76, 72, 78, 79, 90, 63
// mobility 2: 3, 47, 31, 51, 35, 20
// mobility 4: 32, 50, 145, 209, 130, 240, 169, 80, 60, 199
std::vector<int> ids = {66, 81, 20, 39, 91, 30, 61, 47, 68, 107};

// mobility 0: 849.06, 669.23, ids = {107, 68}
double rsuPosX = 849.06, rsuPosY = 669.23;

std::vector<double> distance;
std::vector<MyNode> nodes;
double nodeX = 913.0, nodeY = 757.1;

class MyTag : public Tag {
   public:
    static TypeId GetTypeId(void);
    virtual TypeId GetInstanceTypeId(void) const;
    virtual uint32_t GetSerializedSize(void) const;
    virtual void Serialize(TagBuffer i) const;
    virtual void Deserialize(TagBuffer i);
    virtual void Print(std::ostream &os) const;
    // these are our accessors to our tag structure
    void SetSimpleValue(uint8_t value);
    void SetXCoord(double value);
    void SetYCoord(double value);
    void SetId(uint32_t value);

    uint8_t GetSimpleValue(void) const;
    double GetXCoord(void) const;
    double GetYCoord(void) const;
    uint32_t GetId(void) const;

   private:
    uint8_t m_simpleValue;
    double xCoord;
    double yCoord;
    uint32_t id;
};
TypeId MyTag::GetTypeId(void) {
    static TypeId tid = TypeId("ns3::MyTag").SetParent<Tag>().AddConstructor<MyTag>().AddAttribute("SimpleValue", "A simple value", EmptyAttributeValue(), MakeUintegerAccessor(&MyTag::GetSimpleValue), MakeUintegerChecker<uint8_t>());
    return tid;
}
TypeId MyTag::GetInstanceTypeId(void) const {
    return GetTypeId();
}
uint32_t MyTag::GetSerializedSize(void) const {
    return 21;
}
void MyTag::Serialize(TagBuffer i) const {
    i.WriteU8(m_simpleValue);
    i.WriteDouble(xCoord);
    i.WriteDouble(yCoord);
    i.WriteU32(id);
}
void MyTag::Deserialize(TagBuffer i) {
    m_simpleValue = i.ReadU8();
    xCoord = i.ReadDouble();
    yCoord = i.ReadDouble();
    id = i.ReadU32();
}
void MyTag::Print(std::ostream &os) const {
    os << "v=" << (uint8_t)m_simpleValue;
    os << "x=" << (double)xCoord;
    os << "y=" << (double)yCoord;
    os << "id=" << (uint32_t)id;
}
void MyTag::SetSimpleValue(uint8_t value) {
    m_simpleValue = value;
}
uint8_t MyTag::GetSimpleValue(void) const {
    return m_simpleValue;
}
void MyTag::SetXCoord(double value) {
    xCoord = value;
}
double MyTag::GetXCoord(void) const {
    return xCoord;
}
void MyTag::SetYCoord(double value) {
    yCoord = value;
}
double MyTag::GetYCoord(void) const {
    return yCoord;
}
void MyTag::SetId(uint32_t value) {
    id = value;
}
uint32_t MyTag::GetId(void) const {
    return id;
}

class HandlerParams {
   public:
    Address toRef;
    Ptr<Socket> mySocket;
    uint32_t pktCount;
    Time pktInterval;
    uint8_t type;
    double x;
    double y;
    uint32_t toId;
    uint32_t fromId;
};

static void GenerateTraffic(Ptr<Socket> socket, uint32_t pktSize,
                            uint32_t pktCount, Time pktInterval) {
    if (pktCount > 0) {
        MyTag tag;
        tag.SetSimpleValue(0x58);
        // store the tag in a packet.
        Ptr<Packet> p = Create<Packet>(pktSize);
        p->AddPacketTag(tag);
        socket->Send(p);
        Simulator::Schedule(pktInterval, &GenerateTraffic,
                            socket, pktSize, pktCount - 1, pktInterval);
    }
}

void Handler(HandlerParams params) {
    if (params.pktCount > 0) {
        // uint8_t value = 1;
        uint32_t size = 1000;
        MyTag tag;
        tag.SetSimpleValue(params.type);
        tag.SetXCoord(params.x);
        tag.SetYCoord(params.y);
        tag.SetId(params.fromId);
        Ptr<Packet> p = Create<Packet>(size);
        p->AddPacketTag(tag);
        params.mySocket->SendTo(p, params.toId, params.toRef);
        params.pktCount -= 1;
        Simulator::Schedule(params.pktInterval, &Handler, params);
    }
}

void RSUReceiveCallback(Ptr<Socket> socket) {
    Ptr<Packet> packet;
    Address from;
    uint32_t pktCount = 1;
    double interval = 0.005;  // seconds
    TypeId tid = TypeId::LookupByName("ns3::UdpSocketFactory");
    Time interPacketInterval = Seconds(interval);

    while (packet = socket->RecvFrom(from)) {
        // Ipv4Address address = InetSocketAddress::ConvertFrom(from).GetIpv4();

        MyTag tagCopy;
        packet->PeekPacketTag(tagCopy);

        // std::cout << "Packet received at RSU" << tagCopy.GetSimpleValue() << std::endl;

        // NS_LOG_UNCOND("Received one packet at RSU!\t"
        //               << "At \t " << Simulator::Now().GetSeconds() << "  from  " << address);

        if (tagCopy.GetSimpleValue() == 'X') {
            std::cout << "Emergency message received at RSU." << std::endl;

            uint8_t rsu = 0x52;

            HandlerParams params;

            params.toRef = from;
            params.mySocket = socket;
            params.pktCount = pktCount;
            params.pktInterval = interPacketInterval;
            params.type = rsu;
            params.x = rsuPosX;
            params.y = rsuPosY;
            params.toId = patientNode;
            params.fromId = 1;

            Handler(params);
        }
    }
}

class MyReceiver {
   public:
    MyReceiver(int id, Ptr<Socket> mySocket) {
        this->id = id;
        this->mySocket = mySocket;
    }

    void ReceivePacketPatient(Ptr<Socket> socket) {
        Ptr<Packet> packet;
        Address from;

        while (packet = socket->RecvFrom(from)) {
            // Ipv4Address address = InetSocketAddress::ConvertFrom(from).GetIpv4();

            MyTag tagCopy;
            packet->PeekPacketTag(tagCopy);

            std::cout << "Packet received at patient from node with id = " << tagCopy.GetId() << std::endl;

            std::cout << "Packet received from position, x =  " << tagCopy.GetXCoord() << ", y = " << tagCopy.GetYCoord() << std::endl;

            distance.push_back(tagCopy.GetXCoord());
            distance.push_back(tagCopy.GetYCoord());

            MyNode n;
            n.addr = from;
            n.x = tagCopy.GetXCoord();
            n.y = tagCopy.GetYCoord();
            n.id = tagCopy.GetId();
            n.type = tagCopy.GetSimpleValue();

            nodes.push_back(n);
        }
    }

    void ReceivePacket(Ptr<Socket> socket) {
        Ptr<Packet> packet;
        Address from;
        uint32_t pktCount = 1;
        double interval = 0.005;  // seconds
        TypeId tid = TypeId::LookupByName("ns3::UdpSocketFactory");
        Time interPacketInterval = Seconds(interval);

        while (packet = socket->RecvFrom(from)) {
            // Ipv4Address address = InetSocketAddress::ConvertFrom(from).GetIpv4();

            MyTag tagCopy;
            packet->PeekPacketTag(tagCopy);

            // NS_LOG_UNCOND("Received one packet! \t"
            //               << "At \t " << Simulator::Now().GetSeconds()
            //               << "  from  " << address << "  to  id " << this->id);

            Ptr<MobilityModel> mob = stas.Get(this->id)->GetObject<MobilityModel>();
            double x = mob->GetPosition().x;
            double y = mob->GetPosition().y;

            // std::cout << "My position is " << x << " " << y << std::endl;

            if (tagCopy.GetSimpleValue() == 'X') {
                std::cout << "AV Node " << this->id << " received emergency msg." << std::endl;

                uint8_t av = 0x41;

                HandlerParams params;

                params.toRef = from;
                params.mySocket = this->mySocket;
                params.pktCount = pktCount;
                params.pktInterval = interPacketInterval;
                params.type = av;
                params.x = x;
                params.y = y;
                params.toId = patientNode;
                params.fromId = this->id;

                Handler(params);

            } else if (tagCopy.GetSimpleValue() == 'P') {
                std::cout << "AV Node " << this->id << " received parking msg." << std::endl;
                std::cout << "Av Node " << this->id << " is moving towards the parking area with x = " << tagCopy.GetXCoord() << ", y = " << tagCopy.GetYCoord() << std::endl;
            }
        }
    }

   private:
    int id = -1;
    Ptr<Socket> mySocket;
};

// Prints actual position and velocity when a course change event occurs
static void CourseChange(std::ostream *os, std::string foo, Ptr<const MobilityModel> mobility) {
    Vector pos = mobility->GetPosition();  // Get position
    Vector vel = mobility->GetVelocity();  // Get velocity

    // Prints position and velocities
    *os << Simulator::Now() << " POS: x=" << pos.x << ", y=" << pos.y
        << ", z=" << pos.z << "; VEL:" << vel.x << ", y=" << vel.y
        << ", z=" << vel.z << std::endl;
}

void movePatientHelper(uint32_t node, uint32_t helper) {
    Ptr<MobilityModel> mob = stas.Get(node)->GetObject<MobilityModel>();
    double x = mob->GetPosition().x;
    double y = mob->GetPosition().y;
    std::cout << "Time = " << Simulator::Now().GetSeconds() << std::endl;

    std::cout << "I am at x = " << x << ", y = " << y << std::endl;

    mob = stas.Get(helper)->GetObject<MobilityModel>();
    double x1 = mob->GetPosition().x;
    double y1 = mob->GetPosition().y;

    std::cout << "Helper node is at x = " << x1 << ", y = " << y1 << std::endl;

    if (abs(x - nodeX) > 0.001 || abs(y - nodeY) > 0.001 || abs(x1 - nodeX) > 0.001 || abs(y1 - nodeY) > 0.001) {
        Simulator::Schedule(Seconds(1.0), &movePatientHelper, node, helper);
    }
}

void movePatient(uint32_t node) {
    Ptr<MobilityModel> mob = stas.Get(node)->GetObject<MobilityModel>();
    double x = mob->GetPosition().x;
    double y = mob->GetPosition().y;

    std::cout << "Time = " << Simulator::Now().GetSeconds() << std::endl;
    std::cout << "I am at x = " << x << ", y = " << y << std::endl;

    if (abs(x - nodeX) > 0.001 || abs(y - nodeY) > 0.001) {
        Simulator::Schedule(Seconds(1.0), &movePatient, node);
    }
}

void shortestDist(Ptr<Socket> patientSocket) {
    Ptr<MobilityModel> mob = stas.Get(patientNode)->GetObject<MobilityModel>();
    double x = mob->GetPosition().x;
    double y = mob->GetPosition().y;

    std::cout << "My position is " << x << " " << y << std::endl;

    std::vector<std::pair<double, std::pair<double, double>>> shortest;
    for (auto it = distance.cbegin(); it != distance.cend(); it = it + 2) {
        shortest.push_back({abs(x - *it) + abs(y - *(it + 1)), {*it, *(it + 1)}});
    }

    double min = 99999;
    int num = 0;
    MyNode helperNode;

    for (auto it = shortest.cbegin(); it != shortest.cend(); it++) {
        if (min > it->first) {
            min = it->first;
            helperNode = nodes[num];
        }
        num++;
    }

    std::cout << "Receiving help from node with id = " << helperNode.id << ", type = " << helperNode.type << std::endl;

    if (helperNode.type == 'A') {
        uint8_t av = 0x50;

        HandlerParams params;

        double interval = 1.0;  // seconds
        Time interPacketInterval = Seconds(interval);

        params.toRef = helperNode.addr;
        params.mySocket = patientSocket;
        params.pktCount = 1;
        params.pktInterval = interPacketInterval;
        params.type = av;
        params.x = nodeX;
        params.y = nodeY;
        params.toId = helperNode.id;
        params.fromId = patientNode;

        Handler(params);

        std::cout << "Min dist is " << min << " at node id = " << helperNode.id << std::endl;
        std::cout << "Moving towards the nearest parking area with x = " << nodeX << ", y = " << nodeY << std::endl;

        movePatientHelper(patientNode, helperNode.id);
    } else if (helperNode.type == 'R') {
        std::cout << "Moving towards hospital with x = " << helperNode.x << ", y = " << helperNode.y << std::endl;
        nodeX = helperNode.x;
        nodeY = helperNode.y;
        movePatient(patientNode);
    }
}

// Example to use ns2 traces file in ns3
int main(int argc, char *argv[]) {
    std::string traceFile;
    std::string logFile;

    int nodeNum;
    double duration;

    std::string phyMode("OfdmRate6MbpsBW10MHz");
    uint32_t packetSize = 1000;  // bytes
    uint32_t numPackets = 1;
    double interval = 10.0;  // seconds
    bool verbose = false;

    // Enable logging from the ns2 helper
    LogComponentEnable("Ns2MobilityHelper", LOG_LEVEL_DEBUG);

    // Parse command line attribute
    CommandLine cmd(__FILE__);
    cmd.AddValue("traceFile", "Ns2 movement trace file", traceFile);
    cmd.AddValue("nodeNum", "Number of nodes", nodeNum);
    cmd.AddValue("duration", "Duration of Simulation", duration);
    cmd.AddValue("logFile", "Log file", logFile);
    cmd.AddValue("phyMode", "Wifi Phy mode", phyMode);
    cmd.AddValue("packetSize", "size of application packet sent", packetSize);
    cmd.AddValue("numPackets", "number of packets generated", numPackets);
    cmd.AddValue("interval", "interval (seconds) between packets", interval);
    cmd.AddValue("verbose", "turn on all WifiNetDevice log components", verbose);
    cmd.Parse(argc, argv);

    // Check command line arguments
    if (traceFile.empty() || nodeNum <= 0 || duration <= 0 || logFile.empty()) {
        std::cout << "Usage of " << argv[0] << " :\n\n"
                                               "./waf --run \"ns2-mobility-trace"
                                               " --traceFile=src/mobility/examples/default.ns_movements"
                                               " --nodeNum=2 --duration=100.0 --logFile=ns2-mob.log\" \n\n"
                                               "NOTE: ns2-traces-file could be an absolute or relative path. You could use the file default.ns_movements\n"
                                               "      included in the same directory of this example file.\n\n"
                                               "NOTE 2: Number of nodes present in the trace file must match with the command line argument and must\n"
                                               "        be a positive number. Note that you must know it before to be able to load it.\n\n"
                                               "NOTE 3: Duration must be a positive number. Note that you must know it before to be able to load it.\n\n";

        return 0;
    }

    // Create Ns2MobilityHelper with the specified trace log file as parameter
    Ns2MobilityHelper ns2 = Ns2MobilityHelper(traceFile);

    // open log file for output
    std::ofstream os;
    os.open(logFile.c_str());

    Time interPacketInterval = Seconds(interval);
    // Create all nodes.
    stas.Create(nodeNum);

    rsu.Create(3);

    // The below set of helpers will help us to put together the wifi NICs we want
    YansWifiPhyHelper wifiPhy;
    wifiPhy.SetErrorRateModel("ns3::NistErrorRateModel");
    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();
    Ptr<YansWifiChannel> channel = wifiChannel.Create();
    wifiPhy.SetChannel(channel);
    // ns-3 supports generate a pcap trace
    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11);
    NqosWaveMacHelper wifi80211pMac = NqosWaveMacHelper::Default();

    wifiPhy.Set("TxPowerStart", DoubleValue(16.1589));
    wifiPhy.Set("TxPowerEnd", DoubleValue(16.1589));

    Wifi80211pHelper wifi80211p = Wifi80211pHelper::Default();
    if (verbose) {
        wifi80211p.EnableLogComponents();  // Turn on all Wifi 802.11p logging
    }
    wifi80211p.SetRemoteStationManager("ns3::ConstantRateWifiManager",
                                       "DataMode", StringValue(phyMode),
                                       "ControlMode", StringValue(phyMode));

    NetDeviceContainer devices = wifi80211p.Install(wifiPhy, wifi80211pMac, stas);
    NetDeviceContainer rsuDevices = wifi80211p.Install(wifiPhy, wifi80211pMac, rsu);

    // Tracing
    wifiPhy.EnablePcap("wave-simple-80211p", devices);

    ns2.Install();  // configure movements for each node, while reading trace file

    // Configure callback for logging
    Config::Connect("/NodeList/*/$ns3::MobilityModel/CourseChange",
                    MakeBoundCallback(&CourseChange, &os));

    AodvHelper aodv;
    OlsrHelper olsr;
    Ipv4ListRoutingHelper listrouting;
    // listrouting.Add(olsr, 10);                          // generates less traffic
    listrouting.Add(aodv, 10);  // fastest to find new routes

    InternetStackHelper internet;
    // internet.SetRoutingHelper(listrouting);
    internet.Install(stas);
    internet.Install(rsu);

    MobilityHelper mobility;
    mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
    mobility.Install(rsu);

    Ipv4AddressHelper ipv4;
    NS_LOG_INFO("Assign IP Addresses.");
    ipv4.SetBase("10.0.0.0", "255.255.252.0");
    Ipv4InterfaceContainer i = ipv4.Assign(devices);
    Ipv4InterfaceContainer rsui = ipv4.Assign(rsuDevices);
    TypeId tid = TypeId::LookupByName("ns3::UdpSocketFactory");

    // Creating socket for all the nodes.
    for (NodeContainer::Iterator n = stas.Begin(); n != stas.End(); n++) {
        Ptr<Node> object = *n;
        if (object->GetId() == patientNode) {
            continue;
        }
        Ptr<Socket> recvSink = Socket::CreateSocket(object, tid);
        MyReceiver *receiverptr = new MyReceiver(object->GetId(), recvSink);
        auto id = object->GetId();
        auto it = std::find(ids.begin(), ids.end(), id);
        if (it != ids.end()) {
            InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);
            recvSink->Bind(local);
            InetSocketAddress remote = InetSocketAddress(Ipv4Address("255.255.255.255"), 80);
            recvSink->Connect(remote);
            recvSink->SetRecvCallback(MakeCallback(&MyReceiver::ReceivePacket, receiverptr));
        }
    }

    // Creating socket for RSU 0.
    Ptr<Socket> recvSinkRSU = Socket::CreateSocket(rsu.Get(0), tid);
    InetSocketAddress localRSU = InetSocketAddress(Ipv4Address::GetAny(), 80);
    recvSinkRSU->Bind(localRSU);
    InetSocketAddress remoteRSU = InetSocketAddress(Ipv4Address("255.255.255.255"), 80);
    recvSinkRSU->Connect(remoteRSU);
    recvSinkRSU->SetRecvCallback(MakeCallback(&RSUReceiveCallback));

    // Creating socket for node 1.
    Ptr<Socket> patientSocket = Socket::CreateSocket(stas.Get(patientNode), tid);
    MyReceiver *receiverptr1 = new MyReceiver(patientNode, patientSocket);
    InetSocketAddress local1 = InetSocketAddress(Ipv4Address::GetAny(), 80);
    patientSocket->Bind(local1);
    patientSocket->SetRecvCallback(MakeCallback(&MyReceiver::ReceivePacketPatient, receiverptr1));

    InetSocketAddress remote = InetSocketAddress(Ipv4Address("255.255.255.255"), 80);
    patientSocket->SetAllowBroadcast(true);
    patientSocket->Connect(remote);

    // Sending the broadcast packet from node 1.
    Simulator::ScheduleWithContext(patientSocket->GetNode()->GetId(),
                                   Seconds(emergencyOccurenceTime), &GenerateTraffic,
                                   patientSocket, packetSize, numPackets, interPacketInterval);

    // wifiPhyHelper.EnablePcap (tracebase, devices);

    Simulator::Schedule(Seconds(emergencyOccurenceTime + 2.0), &shortestDist, patientSocket);

    AsciiTraceHelper ascii;
    wifiPhy.EnableAsciiAll(ascii.CreateFileStream(tracebase + ".tr"));

    Simulator::Stop(Seconds(duration));

    AnimationInterface anim("vehicularanimation.xml");

    Ptr<ConstantPositionMobilityModel> s1 = rsu.Get(0)->GetObject<ConstantPositionMobilityModel>();
    Ptr<ConstantPositionMobilityModel> s2 = rsu.Get(1)->GetObject<ConstantPositionMobilityModel>();
    Ptr<ConstantPositionMobilityModel> s3 = rsu.Get(2)->GetObject<ConstantPositionMobilityModel>();

    s1->SetPosition(Vector(rsuPosX, rsuPosY, 0));
    s2->SetPosition(Vector(817.0, 381.0, 0));
    s3->SetPosition(Vector(817.1, 0.0, 0));

    // std::string enqueue_path = "/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/*/$ns3::OcbWifiMac/*/Queue/Enqueue";
    // std::string dequeue_path = "/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/*/$ns3::OcbWifiMac/*/Queue/Dequeue";
    // Config::Connect(enqueue_path, MakeCallback(&EnqueueTrace));
    // Config::Connect(dequeue_path, MakeCallback(&DequeueTrace));

    Simulator::Run();
    Simulator::Destroy();

    os.close();  // close log file
    return 0;
}
